
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module main(

	//////////// CLOCK //////////
	input 		          		CLOCK2_50,
	input 		          		CLOCK3_50,
	input 		          		CLOCK4_50,
	input 		          		CLOCK_50,

	//////////// SEG7 //////////
	output		     [6:0]		HEX0,
	output		     [6:0]		HEX1,
	output		     [6:0]		HEX2,
	output		     [6:0]		HEX3,
	output		     [6:0]		HEX4,
	output		     [6:0]		HEX5,

	//////////// KEY //////////
	input 		     [3:0]		KEY,

	//////////// LED //////////
	output		     [9:0]		LEDR,

	//////////// SW //////////
	input 		     [9:0]		SW,

	//////////// VGA //////////
	output		          		VGA_BLANK_N,
	output		     [7:0]		VGA_B,
	output		          		VGA_CLK,
	output		     [7:0]		VGA_G,
	output		          		VGA_HS,
	output		     [7:0]		VGA_R,
	output		          		VGA_SYNC_N,
	output		          		VGA_VS,

	//////////// GPIO_0, GPIO_0 connect to GPIO Default //////////
	inout 		    [35:0]		keypadGPIO
);

	wire game_mode = SW[8]; // 0 for 1P, 1 for 2P
	wire reset_button = SW[9];
	wire logic_clk = SW[1] ? ~KEY[0] : clk_60Hz;
	wire ai_clk;

    assign VGA_CLK     = CLOCK_50;
    assign VGA_BLANK_N = 1'b1;
    assign VGA_SYNC_N  = 1'b0;
    // === Clock Divider for 60Hz and AI ===
    wire clk_60Hz;
    Clock_Divider #(.DIV(833_333)) clk_div_inst (
        .clk(CLOCK_50),
        .clk_out(clk_60Hz)
    );
	  Clock_Divider #(20) CLK_DIVA ( // 3Hz clock for AI to make 2 decisions per second
	  .clk(clk_60Hz),
	  .clk_out(ai_clk)
 );

	 // === Player Positions (add your Y coordinate logic or constants here) ===
	wire [9:0] player1_pos_x;
	wire [9:0] player2_pos_x;
	wire [9:0] player1_pos_y = 10'd200; // example fixed y, update as needed
	wire [9:0] player2_pos_y = 10'd200; // example fixed y, update as needed

	// === Player States and flags ===
	wire [3:0] player1_state, player2_state;
	wire player1_dir_attack, player2_dir_attack;
	wire move_flag_p1, attack_flag_p1;
	wire move_flag_p2, attack_flag_p2;
	wire [1:0] stunmode1, stunmode2;
	wire [2:0] p1_health, p2_health, p1_shield, p2_shield;
	wire instun1 = player1_state == 4'd9 | player1_state == 4'd10;
	wire instun2 = player2_state == 4'd9 | player2_state == 4'd10;

	// === Keypad scanner for Player 2 inputs  === 
			
	wire [3:0] col, keypad_btns;
	wire [2:0] ai_action;
	wire row, p2_inleft, p2_atk, p2_inright;

	assign keypadGPIO[11] = 1'b0; //row;

	assign col[0] = keypadGPIO[19];
	assign col[1] = keypadGPIO[21];
	assign col[2] = keypadGPIO[23];
	assign col[3] = keypadGPIO[25];
	
	// game_mode = 0 for 1P, 1 for 2P 
	assign p2_inleft    = game_mode? ~col[3]: ai_action[2]; // btn A 
	assign p2_inright   = game_mode? ~col[1]: ai_action[1]; // btn 2
	assign p2_atk 		  = game_mode? ~col[2]: ai_action[0]; // btn 3

	p2ai p2ai_inst (
		.clk(ai_clk),
		.seed(3'b110), // Seed value for LFSR
		.reset(reset_button),
		.le(~KEY[0]),
		.p2_action(ai_action)
	);
	
		hexto7seg ai_lfsr(
		.hex({1'b0,ai_action}),
		.hexn(HEX4)
		);

    // === Gameplay Controllers ===
    GameplayControllerP1 player1 (
		.logic_clk(logic_clk),
		.reset(reset_button),
		.in_left(~KEY[3]),
		.in_right(~KEY[1]),
		.attack(~KEY[2]),
		.player2_pos_x(player2_pos_x),
		.player2_state(player2_state),
		.shield1(p1_shield),
		.shield2(p2_shield),
		.screen_left_bound(0),
		.screen_right_bound(640),
		.player_pos_x(player1_pos_x),
		.player_state(player1_state),
		.is_directional_attack(player1_dir_attack),
		.move_flag(move_flag_p1),
		.attack_flag(attack_flag_p1),
		.stunmode(stunmode1),
		.stunmode2(stunmode2)
    );
	 
    GameplayControllerP2 player2 (
		.logic_clk(logic_clk),
		.reset(reset_button),
		.in_left(p2_inleft), //was SW[5]
		.in_right(p2_inright), // was SW[3]
		.attack(p2_atk), // was SW[4]
		.player1_pos_x(player1_pos_x),
		.player1_state(player1_state),
		.screen_left_bound(0),
		.screen_right_bound(640),
		.player_pos_x(player2_pos_x),
		.player_state(player2_state),
		.is_directional_attack(player2_dir_attack),
		.move_flag(move_flag_p2),
		.attack_flag(attack_flag_p2),
		.stunmode(stunmode2),
		.stunmode1(stunmode1)
    );   
              
              
    // === VGA Display (connect your VGA module here) ===
	Vga_Display vga_display_inst (
		.clk(CLOCK_50),
		.reset(0),
		.key_left(~KEY[3]),
		.key_right(~KEY[1]),
		.r(VGA_R),
		.g(VGA_G),
		.b(VGA_B),
		.hsync(VGA_HS),
		.vsync(VGA_VS),
		.player_x(player1_pos_x),
		.player_state(player1_state),
		.is_directional_attack(player1_dir_attack),
		.player2_x(player2_pos_x),
		.player2_state(player2_state),
		.is_directional_attack_p2(player2_dir_attack)
		);
	hexto7seg hexy(
		.hex(player1_state),
		.hexn(HEX0)
		);

	hexto7seg hexz(
		.hex(player2_state),
		.hexn(HEX1)
		);
	
	Statuses status_bars(
		.clk(logic_clk),
		.reset(reset_button),
		.instun1(instun1),
		.instun2(instun2),
		.p1_stunmode(stunmode1),
		.p2_stunmode(stunmode2),
		.p1_current_health(p1_health),
		.p1_current_block(p1_shield),
		.p2_current_health(p2_health),
		.p2_current_block(p2_shield),
		.p1wins(LEDR[9]),
		.p2wins(LEDR[8])
	);
    // === Debug LEDs and OUTPUTS ===
    assign LEDR[0] = p2_health[0];
    assign LEDR[1] = p2_health[1];
    assign LEDR[2] = p2_health[2];
    assign LEDR[3] = 0;
    assign LEDR[7] = 0;
    assign LEDR[4] = p1_health[0];
    assign LEDR[5] = p1_health[1];
    assign LEDR[6] = p1_health[2];

	shieldto7seg kjjghj( 
		.p1(p1_shield),
		.p2(p2_shield),
		.seg1(HEX3),
		.seg2(HEX2)
		);

endmodule
