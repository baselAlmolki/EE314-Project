
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module display(


	//////////// CLOCK //////////
	input 		          		CLOCK2_50,
	input 		          		CLOCK3_50,
	input 		          		CLOCK4_50,
	input 		          		CLOCK_50,

	//////////// SDRAM //////////
	output		    [12:0]		DRAM_ADDR,
	output		     [1:0]		DRAM_BA,
	output		          		DRAM_CAS_N,
	output		          		DRAM_CKE,
	output		          		DRAM_CLK,
	output		          		DRAM_CS_N,
	inout 		    [15:0]		DRAM_DQ,
	output		          		DRAM_LDQM,
	output		          		DRAM_RAS_N,
	output		          		DRAM_UDQM,
	output		          		DRAM_WE_N,


	//////////// SEG7 //////////
	output		     [6:0]		HEX0,
	output		     [6:0]		HEX1,
	output		     [6:0]		HEX2,
	output		     [6:0]		HEX3,
	output		     [6:0]		HEX4,
	output		     [6:0]		HEX5,

	//////////// KEY //////////
	input 		     [3:0]		KEY,

	//////////// LED //////////
	output		     [9:0]		LEDR,

	//////////// PS2 //////////
	inout 		          		PS2_CLK,
	inout 		          		PS2_CLK2,
	inout 		          		PS2_DAT,
	inout 		          		PS2_DAT2,

	//////////// SW //////////
	input 		     [9:0]		SW,


	//////////// VGA //////////
	output		          		VGA_BLANK_N,
	output		     [7:0]		VGA_B,
	output		          		VGA_CLK,
	output		     [7:0]		VGA_G,
	output		          		VGA_HS,
	output		     [7:0]		VGA_R,
	output		          		VGA_SYNC_N,
	output		          		VGA_VS
	
//	//////////// GPIO_0, GPIO_0 connect to GPIO Default //////////
//	inout 		    [35:0]		keypadGPIO
	
);

//=======================================================
//  REG/WIRE declarations
//=======================================================

// States
reg [2:0] CS, NS;
wire [2:0] state;
assign state = CS;

// 7-Segment display output regs
reg [6:0] hex0, hex1, hex2, hex3, hex4, hex5;

// Game Mode: 1P -> 0, 2P -> 1
reg mode;

// Countdown Counter 
reg [1:0] counter_control;
wire [7:0] counter_output;

//Game Timer Counter
reg [1:0] timer_control;
wire timer_C = timer_control;

// State names
localparam [2:0] M1P=0,
					  M2P=1,
					  Countdown3=2,
					  Countdown2=3,
					  Countdown1=4,
					  CountdownS=5,
					  GP=6,
					  GO=7;
					  
// GP variables and connections
wire game_mode = mode;
wire reset_button = SW[9] || (~FF && (state != GP || state != GO));
wire game_clk, logic_clk, ai_clk, clk_1hz, FF;
wire [11:0] gametimer;


reg fightFlag;
assign FF = fightFlag;
//assign FF = (state == GP && p1_health != 0 & p2_health != 0) ? 1'b1 : 1'b0;

//fightFlag (FF) acts as a enable signal to the gameplay clock
assign game_clk = (SW[1]) ? ~KEY[0] : clk_60hz ;
assign logic_clk = game_clk && FF;
//Timer for calculating the game time
					  
					  
////=======================================================
////  Structural coding
////=======================================================

//Clocks
//Clock Divider for 60Hz
wire clk_60hz;
Clock_Divider #(.DIV(833_333)) clk_div_inst (
        .clk(CLOCK_50),
        .clk_out(clk_60hz)
    );

//Clock Divider for 25MHz for VGA
wire clk_25mhz;
Clock_Divider #(.DIV(2)) clkdiv25M (
	.clk(CLOCK_50),
	.clk_out(clk_25mhz));
	
//Clock Divider for around 1.5Hz clock or button frequency/40
Clock_Divider #(40) CLK_DIVA ( // 1.5Hz clock for AI to make 3 decisions in 2 seconds
	  .clk(logic_clk),
	  .clk_out(ai_clk));
	  
//Clock Divider for 1Hz clock for timer
Clock_Divider #(60) OneSEC(
	  .clk(logic_clk),
	  .clk_out(clk_1hz));
	  

//Hex Outputs
assign HEX0 = hex0;
assign HEX1 = hex1;
assign HEX2 = hex2;
assign HEX3 = hex3;
assign HEX4 = hex4;
assign HEX5 = hex5;

//Menu Display Output
wire [7:0] menu_r, menu_g, menu_b;
wire menu_hs, menu_vs;
menu_display draw_menu( 
						  .clk(clk_25mhz),        // 25 MHz PLL
                    .rst (),      // Active high reset, manipulated by instantiating module
						  .state(state),
                    .hsync(menu_hs),         // All of the connections to the VGA screen below
                    .vsync(menu_vs),
                    .red(menu_r),
                    .green(menu_g),
                    .blue(menu_b),
                    .sync(),
                    .clk_out(),
                    .blank());

//Countdown Counter
Counter #(8) menu_counter (.control(counter_control), .clk(clk_60hz), .count(counter_output));


// === intiate game timer ===
Counter #(12) GameSecondsElapsed(.control(timer_C),.clk(clk_1hz), .count(gametimer));

// === Player Positions (add your Y coordinate logic or constants here) ===
wire [9:0] player1_pos_x;
wire [9:0] player2_pos_x;
wire [9:0] player1_pos_y = 10'd200; // example fixed y, update as needed
wire [9:0] player2_pos_y = 10'd200; // example fixed y, update as needed

// === Player States and flags ===
wire [3:0] player1_state, player2_state;
wire player1_dir_attack, player2_dir_attack;
wire move_flag_p1, attack_flag_p1;
wire move_flag_p2, attack_flag_p2;
wire [1:0] stunmode1, stunmode2;
wire [2:0] p1_health, p2_health, p1_shield, p2_shield;
wire instun1 = player1_state == 4'd9 | player1_state == 4'd10;
wire instun2 = player2_state == 4'd9 | player2_state == 4'd10;

//// === Keypad scanner for Player 2 inputs  === 
//		
//wire [3:0] col, keypad_btns;
wire [2:0] ai_action;
wire /*row,*/ p2_inleft, p2_atk, p2_inright;
//
//assign keypadGPIO[11] = 1'b0; //row;
//
//assign col[0] = keypadGPIO[19];
//assign col[1] = keypadGPIO[21];
//assign col[2] = keypadGPIO[23];
//assign col[3] = keypadGPIO[25];

// game_mode = 0 for 1P, 1 for 2P 
assign p2_inleft    = /*game_mode? ~col[3]:*/ ai_action[2]; // btn A 
assign p2_inright   = /*game_mode? ~col[1]:*/ ai_action[1]; // btn 2
assign p2_atk 		  = /*game_mode? ~col[2]:*/ ai_action[0]; // btn 3


p2ai #(29242) p2ai_inst ( //seed: any num b/w 1-65535
	.clk(ai_clk),
	.reset(reset_button),
	.action(ai_action));


// === Gameplay Controllers ===
    GameplayControllerP1 player1 (
		.logic_clk(logic_clk),
		.reset(reset_button),
		.in_left(~KEY[3]),
		.in_right(~KEY[1]),
		.attack(~KEY[2]),
		.player2_pos_x(player2_pos_x),
		.player2_state(player2_state),
		.shield1(p1_shield),
		.shield2(p2_shield),
		.screen_left_bound(0),
		.screen_right_bound(640),
		.player_pos_x(player1_pos_x),
		.player_state(player1_state),
		.is_directional_attack(player1_dir_attack),
		.move_flag(move_flag_p1),
		.attack_flag(attack_flag_p1),
		.stunmode(stunmode1),
		.stunmode2(stunmode2)
    );
	 
    GameplayControllerP2 player2 (
		.logic_clk(logic_clk),
		.reset(reset_button),
		.in_left(p2_inleft), //was SW[5]
		.in_right(p2_inright), // was SW[3]
		.attack(p2_atk), // was SW[4]
		.player1_pos_x(player1_pos_x),
		.player1_state(player1_state),
		.screen_left_bound(0),
		.screen_right_bound(640),
		.player_pos_x(player2_pos_x),
		.player_state(player2_state),
		.is_directional_attack(player2_dir_attack),
		.move_flag(move_flag_p2),
		.attack_flag(attack_flag_p2),
		.stunmode(stunmode2),
		.stunmode1(stunmode1)
    );   
			  
// game_display outputs
wire [7:0] game_r, game_g, game_b;
wire game_hs, game_vs;
// === VGA Display (connect your VGA module here) ===
Vga_Display game_display (
	.clk(CLOCK_50),
	.reset(),
	.key_left(~KEY[3]),
	.key_right(~KEY[1]),
	.r(game_r),
	.g(game_g),
	.b(game_b),
	.hsync(game_hs),
	.vsync(game_vs),
	.player_x(player1_pos_x),
	.player_state(player1_state),
	.is_directional_attack(player1_dir_attack),
	.player2_x(player2_pos_x),
	.player2_state(player2_state),
	.is_directional_attack_p2(player2_dir_attack));

Statuses status_bars(
	.clk(logic_clk),
	.reset(reset_button),
	.instun1(instun1),
	.instun2(instun2),
	.p1_stunmode(stunmode1),
	.p2_stunmode(stunmode2),
	.p1_current_health(p1_health),
	.p1_current_block(p1_shield),
	.p2_current_health(p2_health),
	.p2_current_block(p2_shield),
	.p1wins(p1win),
	.p2wins(p2win));

wire p1win, p2win;
	
// === Debug LEDs and OUTPUTS ===
assign LEDR[0] = (state == GP) ? p2_health[0]: 0;
assign LEDR[1] = (state == GP) ? p2_health[1]: 0;
assign LEDR[2] = (state == GP) ? p2_health[2]: 0;
assign LEDR[3] = 0;
assign LEDR[7] = 0;
assign LEDR[4] = (state == GP) ? p1_health[0]: 0;
assign LEDR[5] = (state == GP) ? p1_health[1]: 0;
assign LEDR[6] = (state == GP) ? p1_health[2]: 0;


//Vga Output Determination
assign VGA_R		 = (state == GP) ? game_r : (state == GO) ? game_r : menu_r;
assign VGA_G		 = (state == GP) ? game_g : (state == GO) ? game_g : menu_g;
assign VGA_B		 = (state == GP) ? game_b : (state == GO) ? game_b : menu_b;
assign VGA_HS		 = (state == GP) ? game_hs: (state == GO) ? game_hs: menu_hs;
assign VGA_VS		 = (state == GP) ? game_vs: (state == GO) ? game_vs: menu_vs; 
assign VGA_CLK     = clk_25mhz;
assign VGA_BLANK_N = 1'b1;
assign VGA_SYNC_N  = 1'b0;

//	shieldto7seg kjjghj( 
//		.p1(p1_shield),
//		.p2(p2_shield),
//		.seg1(HEX3),
//		.seg2(HEX2)
//		);

//Game Timer
wire [6:0] T0, T1, T2;
timeTo7seg timerDisplay(
	.gametime(gametimer),
	.seg0(T0),
	.seg1(T1),
	.seg2(T2)
	);

//Ai_LFSR
wire [6:0] AI0;
hexto7seg ai_lfsr(
.hex({1'b0,ai_action}),
.hexn(AI0)
);

//P1 state
wire [6:0] P1s;
hexto7seg hexy(
	.hex(player1_state),
	.hexn(P1s)
	);
	
	
//P2 state
wire [6:0] P2s;
hexto7seg hexz(
	.hex(player2_state),
	.hexn(P2s));

always @(*) begin: COMB
		case (CS)
		
		
			// Menu 1P vs Bot
			M1P: begin
			
				//1P 7seg Code
				hex0 = 7'b111_111_1;
				hex1 = 7'b111_111_1;
				hex2 = 7'b000_110_0;
				hex3 = 7'b111_100_1;
				hex4 = 7'b111_111_1;
				hex5 = 7'b111_111_1;
				
				fightFlag = 1'b0;
				timer_control = 2'b11;
				//Transitions
				if (SW[8]) NS = M1P; //SW[8] reset
				else if (~KEY[0] | ~KEY[1] | ~KEY[2] | ~KEY[3]) begin
					NS = Countdown3;
					mode = 1'b0;
				end
				else if (SW[0]) NS = M2P;
				else NS = M1P;
			end
			
			
			//Menu 2P Case
			M2P: begin
			
				//2P 7seg Code
				hex0 = 7'b111_111_1;
				hex1 = 7'b111_111_1;
				hex2 = 7'b000_110_0;
				hex3 = 7'b010_010_0;
				hex4 = 7'b111_111_1;
				hex5 = 7'b111_111_1;
				
				fightFlag = 1'b0;
				timer_control = 2'b11;

				//Transitions
				if (SW[8]) NS = M1P; //SW[8] reset
				else if (~KEY[0] | ~KEY[1] | ~KEY[2] | ~KEY[3]) begin
					NS = Countdown3;
					mode = 1'b1;
				end
				else if (~SW[0]) NS = M1P;
				else NS = M2P;
			end
			
			
			//Countdown No. 3 State
			Countdown3: begin
				// 7seg display of 333_333
				hex0 = 7'b011_000_0;
				hex1 = 7'b011_000_0;
				hex2 = 7'b011_000_0;
				hex3 = 7'b011_000_0;
				hex4 = 7'b011_000_0;
				hex5 = 7'b011_000_0;
				
				fightFlag = 1'b0;
				timer_control = 2'b11;
				//Counter Increment Start
				counter_control = 2'b01;
				//Transitions
				NS = (SW[8]) ? M1P: (counter_output == 8'b0100_0000)? Countdown2 : Countdown3;
			end
			
			
			//Countdown No. 2 State
			Countdown2: begin
				// 7Seg display of 222_222
				hex0 = 7'b010_010_0;
				hex1 = 7'b010_010_0;
				hex2 = 7'b010_010_0;
				hex3 = 7'b010_010_0;
				hex4 = 7'b010_010_0;
				hex5 = 7'b010_010_0;
				
				fightFlag = 1'b0;
				timer_control = 2'b11;
				//Counter Decrement start
				counter_control = 2'b10;
				//Transiitions
				NS = (SW[8]) ? M1P: (counter_output == 8'b0000_0000)? Countdown1 : Countdown2;
			end
			
			
			//Countdown No. 1 State
			Countdown1: begin
				// Hex code of 111_111
				hex0 = 7'b111_100_1;
				hex1 = 7'b111_100_1;
				hex2 = 7'b111_100_1;
				hex3 = 7'b111_100_1;
				hex4 = 7'b111_100_1;
				hex5 = 7'b111_100_1;
				
				fightFlag = 1'b0;
				timer_control = 2'b11;
				//Counter Increment
				counter_control = 2'b01;
				//Transitions
				NS = (SW[8]) ? M1P: (counter_output == 8'b0100_0000)? CountdownS : Countdown1;
			end
			
			
			//Countdown start state
			CountdownS: begin
				//Blank 7seg
				hex0 = 7'b111_111_1; //_
				hex1 = 7'b111_111_1; //_
				hex2 = 7'b111_111_1; //_
				hex3 = 7'b111_111_1; //_
				hex4 = 7'b111_111_1; //_
				hex5 = 7'b111_111_1; //_
				
				fightFlag = 1'b0;
				timer_control = 2'b11;
				//Counter decrement
				counter_control = 2'b10;
				//Transitions
				NS = (SW[8]) ? M1P: (counter_output == 8'b0000_0000)? GP : CountdownS;
			end
			GP: begin
				
				//7seg for Game Start
//				hex0 = 7'b111_111_1; //_
//				hex1 = 7'b000_011_1; //t
//				hex2 = 7'b000_100_1; //H
//				hex3 = 7'b100_001_0; //G
//				hex4 = 7'b111_100_1; //I
//				hex5 = 7'b000_111_0; //F
				hex0 = P1s; //_
				hex1 = P2s; //t
				hex2 = T0; //H
				hex3 = T1; //G
				hex4 = T2; //I
				hex5 = AI0; //F
				
				fightFlag = 1'b1;
				timer_control = {SW[6],1'b1};
				//Counter hold
				counter_control = 2'b00;
				
				//Transitions: add a transition to GO state
				NS = (SW[8]) ? M1P: (p1win || p2win) ? GO : GP;
			end
			GO: begin
				hex0 = P1s; //_
				hex1 = P2s; //t
				hex2 = T0; //H
				hex3 = T1; //G
				hex4 = T2; //I
				hex5 = AI0; //F
				fightFlag = 1'b0;
				timer_control = 2'b00;
				NS = (SW[8]) ? M1P: GO;
			end
//			default: begin
//			end
			endcase
end

always @(posedge clk_60hz) begin: SEQ
	CS <= NS;
end


endmodule