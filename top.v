
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module top(

	//////////// CLOCK //////////
	input 		          		CLOCK2_50,
	input 		          		CLOCK3_50,
	input 		          		CLOCK4_50,
	input 		          		CLOCK_50,

	//////////// SEG7 //////////
	output		     [6:0]		HEX0,
	output		     [6:0]		HEX1,
	output		     [6:0]		HEX2,
	output		     [6:0]		HEX3,
	output		     [6:0]		HEX4,
	output		     [6:0]		HEX5,

	//////////// KEY //////////
	input 		     [3:0]		KEY,

	//////////// LED //////////
	output		     [9:0]		LEDR,

	//////////// SW //////////
	input 		     [9:0]		SW,

	//////////// VGA //////////
	output		          		VGA_BLANK_N,
	output		     [7:0]		VGA_B,
	output		          		VGA_CLK,
	output		     [7:0]		VGA_G,
	output		          		VGA_HS,
	output		     [7:0]		VGA_R,
	output		          		VGA_SYNC_N,
	output		          		VGA_VS,

	//////////// GPIO_0, GPIO_0 connect to GPIO Default //////////
	inout 		    [35:0]		keypadGPIO
);




// states
reg [2:0] CS, NS;
//wire [2:0] CS;
//assign CS = CS;

// 7-Segment display output regs
reg [6:0] hex0, hex1, hex2, hex3, hex4, hex5;

//Hex Outputs
assign HEX0 = hex0;
assign HEX1 = hex1;
assign HEX2 = hex2;
assign HEX3 = hex3;
assign HEX4 = hex4;
assign HEX5 = hex5;

//LEDs outputs
reg [9:0] ledr;
assign LEDR = ledr;

// state names
localparam [2:0] M1P=0,
					  M2P=1,
					  Countdown3=2,
					  Countdown2=3,
					  Countdown1=4,
					  CountdownS=5,
					  GP=6,
					  GO=7;


//Clocks
//Clock Divider for 60Hz
wire clk_60hz;
Clock_Divider #(.DIV(833_333)) clk_div_inst (
        .clk(CLOCK_50),
        .clk_out(clk_60hz)
    );

//Clock Divider for 25MHz for VGA
wire CLOCK_25;
Clock_Divider #(.DIV(2)) clkdiv25M (
	.clk(CLOCK_50),
	.clk_out(CLOCK_25));
	
//Clock Divider for around 1.5Hz clock or button frequency/40
wire ai_clk;
Clock_Divider #(40) CLK_DIVA ( // 1.5Hz clock for AI to make 3 decisions in 2 seconds
	  .clk(logic_clk),
	  .clk_out(ai_clk));
	  
//Clock Divider for 1Hz clock for timer
wire clk_1hz;
Clock_Divider #(60) OneSEC(
	  .clk(game_clk),
	  .clk_out(clk_1hz));
	  
//Game clock switching and FF enabling signal that is only on during GP state
wire game_clk, logic_clk;
assign game_clk = (SW[1]) ? ~KEY[0] : clk_60hz ;
	//Enable signal
reg fightFlag;
assign FF = fightFlag;
assign logic_clk = game_clk && fightFlag;

// Game Mode: 1P -> 0, 2P -> 1
reg mode;
assign game_mode = mode;
//Resetting variable
reg reset;

// timer/counter enabling signal
//reg timer_E;
//wire T_En = timer_E;

wire [7:0] gametimer;
wire [7:0] time_elapsed;
reg  [1:0] timer_C;

//(CS == GO ) ? 2'b00: (reset_button) ? 2'b11: (CS == GP) ? 2'b01: 2'b11; 
assign time_elapsed = gametimer[7:0];

// === intiate game timer ===
Counter #(8) GameSecondsElapsed(.control(timer_C),.clk((clk_1hz /*&& T_En*/)), .count(gametimer));

// Countdown Counter 
reg [1:0] counter_C;
wire [7:0] counter_output;

//Countdown Counter
Counter #(8) cd_counter (.control(counter_C), .clk(clk_60hz), .count(counter_output));


//Menu Display Output
wire [7:0] menu_r, menu_g, menu_b;
wire menu_hs, menu_vs;
menu_display draw_menu(.clk(CLOCK_25),        
							  .rst (),      
							  .state(CS),
							  .hsync(menu_hs),         
							  .vsync(menu_vs),
							  .red(menu_r),
							  .green(menu_g),
							  .blue(menu_b),
							  .sync(),
							  .clk_out(),
							  .blank(),
							  .P1win(p1win),
							  .P2win(p2win),
							  .draw(draw));
						  
// Game Driver Output : Leonardio Le Picasso
wire [7:0] game_r, game_g, game_b;
wire game_hs, game_vs;
 Picasso Game_Artist(.clk(CLOCK_25),
							.reset(),
							.player_x(player1_pos_x),
							.player_state(player1_state),
							.player2_x(player2_pos_x),
							.player2_state(player2_state),
							.time_elapsed(time_elapsed),
							.p1_health(p1_health),
							.p2_health(p2_health),
							.p1_shield(p1_shield),
							.p2_shield(p2_shield),
							.r(game_r),
							.g(game_g),
							.b(game_b),
							.hsync(game_hs),
							.vsync(game_vs));
	

//Vga Output Determination
assign VGA_R		 = (CS == GP) ? game_r : (CS == GO && menu_r == 8'h00) ? game_r : menu_r;
assign VGA_G		 = (CS == GP) ? game_g : (CS == GO && menu_g == 8'h00) ? game_g : menu_g;
assign VGA_B		 = (CS == GP) ? game_b : (CS == GO && menu_b == 8'h00) ? game_b : menu_b;
assign VGA_HS		 = (CS == GP) ? game_hs: (CS == GO) ? game_hs: menu_hs;
assign VGA_VS		 = (CS == GP) ? game_vs: (CS == GO) ? game_vs: menu_vs; 
assign VGA_CLK     = CLOCK_25;
assign VGA_BLANK_N = 1'b1;
assign VGA_SYNC_N  = 1'b0;

	// === Player Positions (add your Y coordinate logic or constants here) ===
	wire [9:0] player1_pos_x;
	wire [9:0] player2_pos_x;
	wire [9:0] player1_pos_y = 10'd200; // example fixed y, update as needed
	wire [9:0] player2_pos_y = 10'd200; // example fixed y, update as needed

	// === Player states and flags ===
	wire [3:0] player1_state, player2_state;
	wire player1_dir_attack, player2_dir_attack;
	wire move_flag_p1, attack_flag_p1;
	wire move_flag_p2, attack_flag_p2;
	wire [1:0] stunmode1, stunmode2;
	wire [2:0] p1_health, p2_health, p1_shield, p2_shield;
	wire instun1 = player1_state == 4'd9 | player1_state == 4'd10;
	wire instun2 = player2_state == 4'd9 | player2_state == 4'd10;

	// === Keypad scanner for Player 2 inputs  === 
			
	wire [3:0] col, keypad_btns;
	wire [2:0] ai_action;
	wire row, p2_inleft, p2_atk, p2_inright;

	assign keypadGPIO[11] = 1'b0; //row;

	assign col[0] = keypadGPIO[19];
	assign col[1] = keypadGPIO[21];
	assign col[2] = keypadGPIO[23];
	assign col[3] = keypadGPIO[25];
	
	////seed: any num b/w 1-65535
	p2ai #(29242) p2ai_inst(.clk(ai_clk),
									.reset(reset_button),
									.action(ai_action));
	
	// game_mode = 0 for 1P, 1 for 2P 
	assign p2_inleft      = mode ? ~col[3]: ai_action[2]; // btn A 
	assign p2_inright     = mode ? ~col[1]: ai_action[1]; // btn 2
	assign p2_atk 		  	 = mode ? ~col[2]: ai_action[0]; // btn 3


	// === Gameplay Controllers ===
    GameplayControllerP1 player1 (
		.logic_clk(logic_clk),
		.reset(reset),
		.in_left(~KEY[3]),
		.in_right(~KEY[1]),
		.attack(~KEY[2]),
		.player2_pos_x(player2_pos_x),
		.player2_state(player2_state),
		.shield1(p1_shield),
		.shield2(p2_shield),
		.screen_left_bound(0),
		.screen_right_bound(640),
		.player_pos_x(player1_pos_x),
		.player_state(player1_state),
		.move_flag(move_flag_p1),
		.attack_flag(attack_flag_p1),
		.stunmode(stunmode1),
		.stunmode2(stunmode2)
    );
	 
    GameplayControllerP2 player2 (
		.logic_clk(logic_clk),
		.reset(reset),
		.in_left(p2_inleft), //was SW[5]
		.in_right(p2_inright), // was SW[3]
		.attack(p2_atk), // was SW[4]
		.player1_pos_x(player1_pos_x),
		.player1_state(player1_state),
		.screen_left_bound(0),
		.screen_right_bound(640),
		.player_pos_x(player2_pos_x),
		.player_state(player2_state),
		.move_flag(move_flag_p2),
		.attack_flag(attack_flag_p2),
		.stunmode(stunmode2),
		.stunmode1(stunmode1)
    );   
  
	Statuses status_bars(
		.clk(logic_clk),
		.reset(reset),
		.instun1(instun1),
		.instun2(instun2),
		.p1_stunmode(stunmode1),
		.p2_stunmode(stunmode2),
		.p1_current_health(p1_health),
		.p1_current_block(p1_shield),
		.p2_current_health(p2_health),
		.p2_current_block(p2_shield),
		.p1wins(p1win),
		.p2wins(p2win)
	);
	
	wire p1win, p2win;
	wire draw = (p1win && p2win) || (gametimer >= 8'd99);
	
	//Game Timer
wire [6:0] T0, T1;
timeTo7seg timerDisplay(
	.gametime(gametimer),
	.seg0(T0),
	.seg1(T1),	);

//Negtative Edge Detector
wire NE;
NegativeEdgeDetector negedgedet(.button_in((~KEY[0]) | (~KEY[1]) | (~KEY[2]) | (~KEY[3])), .rst(), .clk(clk_60hz), .neg_edge(NE));


always @(*) begin: COMB
		case (CS)
		
		
			// Menu 1P vs Bot
			M1P: begin
			
				//1P 7seg Code
				hex0 = 7'b111_111_1;
				hex1 = 7'b111_111_1;
				hex2 = 7'b000_110_0;
				hex3 = 7'b111_100_1;
				hex4 = 7'b111_111_1;
				hex5 = 7'b111_111_1;
				
				//LEDs Output
				ledr = {10{1'b0}};
				
				//reg values corresponding to this state
				fightFlag 	= 1'b0;
				mode 			= SW[0];
				reset 		= 1'b1;
				timer_C 		= 2'b11;
				counter_C 	= 2'b11;
				
				
				//Transitions
				if (SW[8]) NS = M1P; //SW[8] reset
				else if (((~KEY[0]) || (~KEY[1]) || (~KEY[2]) || (~KEY[3])) && NE) begin
					NS = Countdown3;
					mode = 1'b0;
				end
				else if (SW[0]) begin
					NS = M2P;
					mode = 1'b1;
				end
				else NS = M1P;
			end
			
			
			//Menu 2P Case
			M2P: begin
			
				//2P 7seg Code
				hex0 = 7'b111_111_1;
				hex1 = 7'b111_111_1;
				hex2 = 7'b000_110_0;
				hex3 = 7'b010_010_0;
				hex4 = 7'b111_111_1;
				hex5 = 7'b111_111_1;
				
				//LEDs Output
				ledr = {10{1'b0}};
				
				//reg values corresponding to this state
				fightFlag 	= 1'b0;
				mode 			= SW[0];
				reset 		= 1'b1;
				timer_C 		= 2'b11;
				counter_C 	= 2'b11;
				
				//Transitions
				if (SW[8]) NS = M1P; //SW[8] reset
				else if (((~KEY[0]) || (~KEY[1]) || (~KEY[2]) || (~KEY[3])) && NE) begin
					NS = Countdown3;
					mode = 1'b1;
				end
				else if (~SW[0]) begin
					NS = M1P;
					mode = 1'b0;
				end
				else NS = M2P;
			end
			
			
			//Countdown No. 3 state
			Countdown3: begin
				// 7seg display of 333_333
				hex0 = 7'b011_000_0;
				hex1 = 7'b011_000_0;
				hex2 = 7'b011_000_0;
				hex3 = 7'b011_000_0;
				hex4 = 7'b011_000_0;
				hex5 = 7'b011_000_0;
				
				//reg values corresponding to this state
				fightFlag 	= 1'b0;
				reset 		= 1'b1;
				
				timer_C 		= 2'b11;
				counter_C 	= 2'b01;	//counter starts to increment
				//Transitions
				NS = (SW[8]) ? M1P: (counter_output == 8'b0100_0000)? Countdown2 : Countdown3;
			end
			
			
			//Countdown No. 2 state
			Countdown2: begin
				// 7Seg display of 222_222
				hex0 = 7'b010_010_0;
				hex1 = 7'b010_010_0;
				hex2 = 7'b010_010_0;
				hex3 = 7'b010_010_0;
				hex4 = 7'b010_010_0;
				hex5 = 7'b010_010_0;
				
				//reg values corresponding to this state
				fightFlag 	= 1'b0;
				reset 		= 1'b1;
				
				timer_C 		= 2'b11;
				counter_C 	= 2'b10;	//counter starts to decrement
				//Transiitions
				NS = (SW[8]) ? M1P: (counter_output == 8'b0000_0000)? Countdown1 : Countdown2;
			end
			
			
			//Countdown No. 1 state
			Countdown1: begin
				// Hex code of 111_111
				hex0 = 7'b111_100_1;
				hex1 = 7'b111_100_1;
				hex2 = 7'b111_100_1;
				hex3 = 7'b111_100_1;
				hex4 = 7'b111_100_1;
				hex5 = 7'b111_100_1;
				
				//reg values corresponding to this state
				fightFlag 	= 1'b0;
				reset 		= 1'b1;
				
				timer_C 		= 2'b11;
				counter_C 	= 2'b01;	//counter starts to increment
				//Transitions
				NS = (SW[8]) ? M1P: (counter_output == 8'b0100_0000)? CountdownS : Countdown1;
			end
			
			
			//Countdown start state
			CountdownS: begin
				//Blank 7seg
				hex0 = 7'b111_111_1; //_
				hex1 = 7'b111_111_1; //_
				hex2 = 7'b111_111_1; //_
				hex3 = 7'b111_111_1; //_
				hex4 = 7'b111_111_1; //_
				hex5 = 7'b111_111_1; //_
				
				//reg values corresponding to this state
				fightFlag 	= 1'b0;
				reset 		= 1'b1;
				
				timer_C 		= 2'b11;
				counter_C 	= 2'b10;	//counter starts to decrement
				//Transitions
				NS = (SW[8]) ? M1P: (counter_output == 8'b0000_0000)? GP : CountdownS;
			end
			GP: begin
				
				//7seg for Game Start
				hex0 = 7'b111_111_1; //_
				hex1 = 7'b000_011_1; //t
				hex2 = 7'b000_100_1; //H
				hex3 = 7'b100_001_0; //G
				hex4 = 7'b111_100_1; //I
				hex5 = 7'b000_111_0; //F


				ledr = {p1_health, {4{1'b0}}, p2_health[0], p2_health[1], p2_health[2]};
				
				//reg values corresponding to this state
				fightFlag 	= 1'b1;
				reset 		= SW[9];
				timer_C 		= reset ? 2'b11: 2'b01;
				counter_C 	= 2'b11;	//counter reset
				
				//Transitions: add a transition to GO state
				NS = (SW[8]) ? M1P: (p1win || p2win || draw) ? GO : GP;
			end
			GO: begin
				hex5 = draw ? 7'b000_011_0: 7'b000_110_0; //E (when draw) or P (all other cases)
				hex4 = draw ? 7'b001_100_0: p1win ? 7'b111_100_1: 7'b010_010_0; //q (when draw) or 1 (when p1win) or 2 (otherwise)
				hex3 = 7'b011_111_1; //-
				hex2 = T1; //X
				hex1 = T0; //X
				hex0 = 7'b011_111_1; //-
				
				//ledr output
				ledr = {10{clk_1hz}};
				
				//reg values corresponding to this state
				fightFlag 	= 1'b0;
				reset 		= 1'b0;
				timer_C 		= 2'b00;
				counter_C 	= 2'b01;	//counter reset
				
				//Transitions
				if (SW[8]) NS = M1P; //SW[8] reset
				else if ((counter_output >= 8'b0010_0000) && ((~KEY[0]) || (~KEY[1]) || (~KEY[2]) || (~KEY[3])) && (SW[0]) && NE) NS = M2P;
				else if ((counter_output >= 8'b0010_0000) && ((~KEY[0]) || (~KEY[1]) || (~KEY[2]) || (~KEY[3])) && NE) NS = M1P;
				else NS = GO;
			end
//			default: begin
//			end
			endcase
end

always @(posedge clk_60hz) begin: SEQ
	CS <= NS;
end

endmodule
